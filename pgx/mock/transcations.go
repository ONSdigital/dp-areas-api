// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	pgx "github.com/ONSdigital/dp-areas-api/pgx"
	"github.com/jackc/pgconn"
	v4 "github.com/jackc/pgx/v4"
	"sync"
)

// Ensure, that PGXTransactionMock does implement pgx.PGXTransaction.
// If this is not the case, regenerate this file with moq.
var _ pgx.PGXTransaction = &PGXTransactionMock{}

// PGXTransactionMock is a mock implementation of pgx.PGXTransaction.
//
// 	func TestSomethingThatUsesPGXTransaction(t *testing.T) {
//
// 		// make and configure a mocked pgx.PGXTransaction
// 		mockedPGXTransaction := &PGXTransactionMock{
// 			BeginFunc: func(ctx context.Context) (v4.Tx, error) {
// 				panic("mock out the Begin method")
// 			},
// 			BeginFuncFunc: func(ctx context.Context, f func(v4.Tx) error) error {
// 				panic("mock out the BeginFunc method")
// 			},
// 			CommitFunc: func(ctx context.Context) error {
// 				panic("mock out the Commit method")
// 			},
// 			ConnFunc: func() *v4.Conn {
// 				panic("mock out the Conn method")
// 			},
// 			CopyFromFunc: func(ctx context.Context, tableName v4.Identifier, columnNames []string, rowSrc v4.CopyFromSource) (int64, error) {
// 				panic("mock out the CopyFrom method")
// 			},
// 			ExecFunc: func(ctx context.Context, sql string, arguments ...interface{}) (pgconn.CommandTag, error) {
// 				panic("mock out the Exec method")
// 			},
// 			LargeObjectsFunc: func() v4.LargeObjects {
// 				panic("mock out the LargeObjects method")
// 			},
// 			PrepareFunc: func(ctx context.Context, name string, sql string) (*pgconn.StatementDescription, error) {
// 				panic("mock out the Prepare method")
// 			},
// 			QueryFunc: func(ctx context.Context, sql string, args ...interface{}) (v4.Rows, error) {
// 				panic("mock out the Query method")
// 			},
// 			QueryFuncFunc: func(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(v4.QueryFuncRow) error) (pgconn.CommandTag, error) {
// 				panic("mock out the QueryFunc method")
// 			},
// 			QueryRowFunc: func(ctx context.Context, sql string, args ...interface{}) v4.Row {
// 				panic("mock out the QueryRow method")
// 			},
// 			RollbackFunc: func(ctx context.Context) error {
// 				panic("mock out the Rollback method")
// 			},
// 			SendBatchFunc: func(ctx context.Context, b *v4.Batch) v4.BatchResults {
// 				panic("mock out the SendBatch method")
// 			},
// 		}
//
// 		// use mockedPGXTransaction in code that requires pgx.PGXTransaction
// 		// and then make assertions.
//
// 	}
type PGXTransactionMock struct {
	// BeginMock mocks the Begin method.
	BeginMock func(ctx context.Context) (v4.Tx, error)

	// BeginFuncMock mocks the BeginFunc method.
	BeginFuncMock func(ctx context.Context, f func(v4.Tx) error) error

	// CommitFunc mocks the Commit method.
	CommitFunc func(ctx context.Context) error

	// ConnFunc mocks the Conn method.
	ConnFunc func() *v4.Conn

	// CopyFromFunc mocks the CopyFrom method.
	CopyFromFunc func(ctx context.Context, tableName v4.Identifier, columnNames []string, rowSrc v4.CopyFromSource) (int64, error)

	// ExecFunc mocks the Exec method.
	ExecFunc func(ctx context.Context, sql string, arguments ...interface{}) (pgconn.CommandTag, error)

	// LargeObjectsFunc mocks the LargeObjects method.
	LargeObjectsFunc func() v4.LargeObjects

	// PrepareFunc mocks the Prepare method.
	PrepareFunc func(ctx context.Context, name string, sql string) (*pgconn.StatementDescription, error)

	// QueryFunc mocks the Query method.
	QueryMock func(ctx context.Context, sql string, args ...interface{}) (v4.Rows, error)

	// QueryFuncFunc mocks the QueryFunc method.
	QueryFuncMock func(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(v4.QueryFuncRow) error) (pgconn.CommandTag, error)

	// QueryRowFunc mocks the QueryRow method.
	QueryRowFunc func(ctx context.Context, sql string, args ...interface{}) v4.Row

	// RollbackFunc mocks the Rollback method.
	RollbackFunc func(ctx context.Context) error

	// SendBatchFunc mocks the SendBatch method.
	SendBatchFunc func(ctx context.Context, b *v4.Batch) v4.BatchResults

	// calls tracks calls to the methods.
	calls struct {
		// Begin holds details about calls to the Begin method.
		Begin []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// BeginFunc holds details about calls to the BeginFunc method.
		BeginFunc []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// F is the f argument value.
			F func(v4.Tx) error
		}
		// Commit holds details about calls to the Commit method.
		Commit []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Conn holds details about calls to the Conn method.
		Conn []struct {
		}
		// CopyFrom holds details about calls to the CopyFrom method.
		CopyFrom []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TableName is the tableName argument value.
			TableName v4.Identifier
			// ColumnNames is the columnNames argument value.
			ColumnNames []string
			// RowSrc is the rowSrc argument value.
			RowSrc v4.CopyFromSource
		}
		// Exec holds details about calls to the Exec method.
		Exec []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SQL is the sql argument value.
			SQL string
			// Arguments is the arguments argument value.
			Arguments []interface{}
		}
		// LargeObjects holds details about calls to the LargeObjects method.
		LargeObjects []struct {
		}
		// Prepare holds details about calls to the Prepare method.
		Prepare []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// SQL is the sql argument value.
			SQL string
		}
		// Query holds details about calls to the Query method.
		Query []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SQL is the sql argument value.
			SQL string
			// Args is the args argument value.
			Args []interface{}
		}
		// QueryFunc holds details about calls to the QueryFunc method.
		QueryFunc []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SQL is the sql argument value.
			SQL string
			// Args is the args argument value.
			Args []interface{}
			// Scans is the scans argument value.
			Scans []interface{}
			// F is the f argument value.
			F func(v4.QueryFuncRow) error
		}
		// QueryRow holds details about calls to the QueryRow method.
		QueryRow []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SQL is the sql argument value.
			SQL string
			// Args is the args argument value.
			Args []interface{}
		}
		// Rollback holds details about calls to the Rollback method.
		Rollback []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// SendBatch holds details about calls to the SendBatch method.
		SendBatch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// B is the b argument value.
			B *v4.Batch
		}
	}
	lockBegin        sync.RWMutex
	lockBeginFunc    sync.RWMutex
	lockCommit       sync.RWMutex
	lockConn         sync.RWMutex
	lockCopyFrom     sync.RWMutex
	lockExec         sync.RWMutex
	lockLargeObjects sync.RWMutex
	lockPrepare      sync.RWMutex
	lockQuery        sync.RWMutex
	lockQueryFunc    sync.RWMutex
	lockQueryRow     sync.RWMutex
	lockRollback     sync.RWMutex
	lockSendBatch    sync.RWMutex
}

// Begin calls BeginFunc.
func (mock *PGXTransactionMock) Begin(ctx context.Context) (v4.Tx, error) {
	if mock.BeginMock == nil {
		panic("PGXTransactionMock.BeginFunc: method is nil but PGXTransaction.Begin was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockBegin.Lock()
	mock.calls.Begin = append(mock.calls.Begin, callInfo)
	mock.lockBegin.Unlock()
	return mock.BeginMock(ctx)
}

// BeginCalls gets all the calls that were made to Begin.
// Check the length with:
//     len(mockedPGXTransaction.BeginCalls())
func (mock *PGXTransactionMock) BeginCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockBegin.RLock()
	calls = mock.calls.Begin
	mock.lockBegin.RUnlock()
	return calls
}

// BeginFunc calls BeginFuncFunc.
func (mock *PGXTransactionMock) BeginFunc(ctx context.Context, f func(v4.Tx) error) error {
	if mock.BeginFuncMock == nil {
		panic("PGXTransactionMock.BeginFuncFunc: method is nil but PGXTransaction.BeginFunc was just called")
	}
	callInfo := struct {
		Ctx context.Context
		F   func(v4.Tx) error
	}{
		Ctx: ctx,
		F:   f,
	}
	mock.lockBeginFunc.Lock()
	mock.calls.BeginFunc = append(mock.calls.BeginFunc, callInfo)
	mock.lockBeginFunc.Unlock()
	return mock.BeginFuncMock(ctx, f)
}

// BeginFuncCalls gets all the calls that were made to BeginFunc.
// Check the length with:
//     len(mockedPGXTransaction.BeginFuncCalls())
func (mock *PGXTransactionMock) BeginFuncCalls() []struct {
	Ctx context.Context
	F   func(v4.Tx) error
} {
	var calls []struct {
		Ctx context.Context
		F   func(v4.Tx) error
	}
	mock.lockBeginFunc.RLock()
	calls = mock.calls.BeginFunc
	mock.lockBeginFunc.RUnlock()
	return calls
}

// Commit calls CommitFunc.
func (mock *PGXTransactionMock) Commit(ctx context.Context) error {
	if mock.CommitFunc == nil {
		panic("PGXTransactionMock.CommitFunc: method is nil but PGXTransaction.Commit was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockCommit.Lock()
	mock.calls.Commit = append(mock.calls.Commit, callInfo)
	mock.lockCommit.Unlock()
	return mock.CommitFunc(ctx)
}

// CommitCalls gets all the calls that were made to Commit.
// Check the length with:
//     len(mockedPGXTransaction.CommitCalls())
func (mock *PGXTransactionMock) CommitCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockCommit.RLock()
	calls = mock.calls.Commit
	mock.lockCommit.RUnlock()
	return calls
}

// Conn calls ConnFunc.
func (mock *PGXTransactionMock) Conn() *v4.Conn {
	if mock.ConnFunc == nil {
		panic("PGXTransactionMock.ConnFunc: method is nil but PGXTransaction.Conn was just called")
	}
	callInfo := struct {
	}{}
	mock.lockConn.Lock()
	mock.calls.Conn = append(mock.calls.Conn, callInfo)
	mock.lockConn.Unlock()
	return mock.ConnFunc()
}

// ConnCalls gets all the calls that were made to Conn.
// Check the length with:
//     len(mockedPGXTransaction.ConnCalls())
func (mock *PGXTransactionMock) ConnCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockConn.RLock()
	calls = mock.calls.Conn
	mock.lockConn.RUnlock()
	return calls
}

// CopyFrom calls CopyFromFunc.
func (mock *PGXTransactionMock) CopyFrom(ctx context.Context, tableName v4.Identifier, columnNames []string, rowSrc v4.CopyFromSource) (int64, error) {
	if mock.CopyFromFunc == nil {
		panic("PGXTransactionMock.CopyFromFunc: method is nil but PGXTransaction.CopyFrom was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		TableName   v4.Identifier
		ColumnNames []string
		RowSrc      v4.CopyFromSource
	}{
		Ctx:         ctx,
		TableName:   tableName,
		ColumnNames: columnNames,
		RowSrc:      rowSrc,
	}
	mock.lockCopyFrom.Lock()
	mock.calls.CopyFrom = append(mock.calls.CopyFrom, callInfo)
	mock.lockCopyFrom.Unlock()
	return mock.CopyFromFunc(ctx, tableName, columnNames, rowSrc)
}

// CopyFromCalls gets all the calls that were made to CopyFrom.
// Check the length with:
//     len(mockedPGXTransaction.CopyFromCalls())
func (mock *PGXTransactionMock) CopyFromCalls() []struct {
	Ctx         context.Context
	TableName   v4.Identifier
	ColumnNames []string
	RowSrc      v4.CopyFromSource
} {
	var calls []struct {
		Ctx         context.Context
		TableName   v4.Identifier
		ColumnNames []string
		RowSrc      v4.CopyFromSource
	}
	mock.lockCopyFrom.RLock()
	calls = mock.calls.CopyFrom
	mock.lockCopyFrom.RUnlock()
	return calls
}

// Exec calls ExecFunc.
func (mock *PGXTransactionMock) Exec(ctx context.Context, sql string, arguments ...interface{}) (pgconn.CommandTag, error) {
	if mock.ExecFunc == nil {
		panic("PGXTransactionMock.ExecFunc: method is nil but PGXTransaction.Exec was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		SQL       string
		Arguments []interface{}
	}{
		Ctx:       ctx,
		SQL:       sql,
		Arguments: arguments,
	}
	mock.lockExec.Lock()
	mock.calls.Exec = append(mock.calls.Exec, callInfo)
	mock.lockExec.Unlock()
	return mock.ExecFunc(ctx, sql, arguments...)
}

// ExecCalls gets all the calls that were made to Exec.
// Check the length with:
//     len(mockedPGXTransaction.ExecCalls())
func (mock *PGXTransactionMock) ExecCalls() []struct {
	Ctx       context.Context
	SQL       string
	Arguments []interface{}
} {
	var calls []struct {
		Ctx       context.Context
		SQL       string
		Arguments []interface{}
	}
	mock.lockExec.RLock()
	calls = mock.calls.Exec
	mock.lockExec.RUnlock()
	return calls
}

// LargeObjects calls LargeObjectsFunc.
func (mock *PGXTransactionMock) LargeObjects() v4.LargeObjects {
	if mock.LargeObjectsFunc == nil {
		panic("PGXTransactionMock.LargeObjectsFunc: method is nil but PGXTransaction.LargeObjects was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLargeObjects.Lock()
	mock.calls.LargeObjects = append(mock.calls.LargeObjects, callInfo)
	mock.lockLargeObjects.Unlock()
	return mock.LargeObjectsFunc()
}

// LargeObjectsCalls gets all the calls that were made to LargeObjects.
// Check the length with:
//     len(mockedPGXTransaction.LargeObjectsCalls())
func (mock *PGXTransactionMock) LargeObjectsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLargeObjects.RLock()
	calls = mock.calls.LargeObjects
	mock.lockLargeObjects.RUnlock()
	return calls
}

// Prepare calls PrepareFunc.
func (mock *PGXTransactionMock) Prepare(ctx context.Context, name string, sql string) (*pgconn.StatementDescription, error) {
	if mock.PrepareFunc == nil {
		panic("PGXTransactionMock.PrepareFunc: method is nil but PGXTransaction.Prepare was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Name string
		SQL  string
	}{
		Ctx:  ctx,
		Name: name,
		SQL:  sql,
	}
	mock.lockPrepare.Lock()
	mock.calls.Prepare = append(mock.calls.Prepare, callInfo)
	mock.lockPrepare.Unlock()
	return mock.PrepareFunc(ctx, name, sql)
}

// PrepareCalls gets all the calls that were made to Prepare.
// Check the length with:
//     len(mockedPGXTransaction.PrepareCalls())
func (mock *PGXTransactionMock) PrepareCalls() []struct {
	Ctx  context.Context
	Name string
	SQL  string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
		SQL  string
	}
	mock.lockPrepare.RLock()
	calls = mock.calls.Prepare
	mock.lockPrepare.RUnlock()
	return calls
}

// Query calls QueryFunc.
func (mock *PGXTransactionMock) Query(ctx context.Context, sql string, args ...interface{}) (v4.Rows, error) {
	if mock.QueryMock == nil {
		panic("PGXTransactionMock.QueryFunc: method is nil but PGXTransaction.Query was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		SQL  string
		Args []interface{}
	}{
		Ctx:  ctx,
		SQL:  sql,
		Args: args,
	}
	mock.lockQuery.Lock()
	mock.calls.Query = append(mock.calls.Query, callInfo)
	mock.lockQuery.Unlock()
	return mock.QueryMock(ctx, sql, args...)
}

// QueryCalls gets all the calls that were made to Query.
// Check the length with:
//     len(mockedPGXTransaction.QueryCalls())
func (mock *PGXTransactionMock) QueryCalls() []struct {
	Ctx  context.Context
	SQL  string
	Args []interface{}
} {
	var calls []struct {
		Ctx  context.Context
		SQL  string
		Args []interface{}
	}
	mock.lockQuery.RLock()
	calls = mock.calls.Query
	mock.lockQuery.RUnlock()
	return calls
}

// QueryFunc calls QueryFuncFunc.
func (mock *PGXTransactionMock) QueryFunc(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(v4.QueryFuncRow) error) (pgconn.CommandTag, error) {
	if mock.QueryFuncMock == nil {
		panic("PGXTransactionMock.QueryFuncFunc: method is nil but PGXTransaction.QueryFunc was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		SQL   string
		Args  []interface{}
		Scans []interface{}
		F     func(v4.QueryFuncRow) error
	}{
		Ctx:   ctx,
		SQL:   sql,
		Args:  args,
		Scans: scans,
		F:     f,
	}
	mock.lockQueryFunc.Lock()
	mock.calls.QueryFunc = append(mock.calls.QueryFunc, callInfo)
	mock.lockQueryFunc.Unlock()
	return mock.QueryFuncMock(ctx, sql, args, scans, f)
}

// QueryFuncCalls gets all the calls that were made to QueryFunc.
// Check the length with:
//     len(mockedPGXTransaction.QueryFuncCalls())
func (mock *PGXTransactionMock) QueryFuncCalls() []struct {
	Ctx   context.Context
	SQL   string
	Args  []interface{}
	Scans []interface{}
	F     func(v4.QueryFuncRow) error
} {
	var calls []struct {
		Ctx   context.Context
		SQL   string
		Args  []interface{}
		Scans []interface{}
		F     func(v4.QueryFuncRow) error
	}
	mock.lockQueryFunc.RLock()
	calls = mock.calls.QueryFunc
	mock.lockQueryFunc.RUnlock()
	return calls
}

// QueryRow calls QueryRowFunc.
func (mock *PGXTransactionMock) QueryRow(ctx context.Context, sql string, args ...interface{}) v4.Row {
	if mock.QueryRowFunc == nil {
		panic("PGXTransactionMock.QueryRowFunc: method is nil but PGXTransaction.QueryRow was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		SQL  string
		Args []interface{}
	}{
		Ctx:  ctx,
		SQL:  sql,
		Args: args,
	}
	mock.lockQueryRow.Lock()
	mock.calls.QueryRow = append(mock.calls.QueryRow, callInfo)
	mock.lockQueryRow.Unlock()
	return mock.QueryRowFunc(ctx, sql, args...)
}

// QueryRowCalls gets all the calls that were made to QueryRow.
// Check the length with:
//     len(mockedPGXTransaction.QueryRowCalls())
func (mock *PGXTransactionMock) QueryRowCalls() []struct {
	Ctx  context.Context
	SQL  string
	Args []interface{}
} {
	var calls []struct {
		Ctx  context.Context
		SQL  string
		Args []interface{}
	}
	mock.lockQueryRow.RLock()
	calls = mock.calls.QueryRow
	mock.lockQueryRow.RUnlock()
	return calls
}

// Rollback calls RollbackFunc.
func (mock *PGXTransactionMock) Rollback(ctx context.Context) error {
	if mock.RollbackFunc == nil {
		panic("PGXTransactionMock.RollbackFunc: method is nil but PGXTransaction.Rollback was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockRollback.Lock()
	mock.calls.Rollback = append(mock.calls.Rollback, callInfo)
	mock.lockRollback.Unlock()
	return mock.RollbackFunc(ctx)
}

// RollbackCalls gets all the calls that were made to Rollback.
// Check the length with:
//     len(mockedPGXTransaction.RollbackCalls())
func (mock *PGXTransactionMock) RollbackCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockRollback.RLock()
	calls = mock.calls.Rollback
	mock.lockRollback.RUnlock()
	return calls
}

// SendBatch calls SendBatchFunc.
func (mock *PGXTransactionMock) SendBatch(ctx context.Context, b *v4.Batch) v4.BatchResults {
	if mock.SendBatchFunc == nil {
		panic("PGXTransactionMock.SendBatchFunc: method is nil but PGXTransaction.SendBatch was just called")
	}
	callInfo := struct {
		Ctx context.Context
		B   *v4.Batch
	}{
		Ctx: ctx,
		B:   b,
	}
	mock.lockSendBatch.Lock()
	mock.calls.SendBatch = append(mock.calls.SendBatch, callInfo)
	mock.lockSendBatch.Unlock()
	return mock.SendBatchFunc(ctx, b)
}

// SendBatchCalls gets all the calls that were made to SendBatch.
// Check the length with:
//     len(mockedPGXTransaction.SendBatchCalls())
func (mock *PGXTransactionMock) SendBatchCalls() []struct {
	Ctx context.Context
	B   *v4.Batch
} {
	var calls []struct {
		Ctx context.Context
		B   *v4.Batch
	}
	mock.lockSendBatch.RLock()
	calls = mock.calls.SendBatch
	mock.lockSendBatch.RUnlock()
	return calls
}
