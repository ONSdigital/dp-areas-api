// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/ONSdigital/dp-areas-api/pgx"
	"github.com/jackc/pgconn"
	"github.com/jackc/pgproto3/v2"
	"sync"
)

// Ensure, that PGXRowsMock does implement pgx.PGXRows.
// If this is not the case, regenerate this file with moq.
var _ pgx.PGXRows = &PGXRowsMock{}

// PGXRowsMock is a mock implementation of pgx.PGXRows.
//
// 	func TestSomethingThatUsesPGXRows(t *testing.T) {
//
// 		// make and configure a mocked pgx.PGXRows
// 		mockedPGXRows := &PGXRowsMock{
// 			CloseFunc: func()  {
// 				panic("mock out the Close method")
// 			},
// 			CommandTagFunc: func() pgconn.CommandTag {
// 				panic("mock out the CommandTag method")
// 			},
// 			ErrFunc: func() error {
// 				panic("mock out the Err method")
// 			},
// 			FieldDescriptionsFunc: func() []pgproto3.FieldDescription {
// 				panic("mock out the FieldDescriptions method")
// 			},
// 			NextFunc: func() bool {
// 				panic("mock out the Next method")
// 			},
// 			RawValuesFunc: func() [][]byte {
// 				panic("mock out the RawValues method")
// 			},
// 			ScanFunc: func(dest ...interface{}) error {
// 				panic("mock out the Scan method")
// 			},
// 			ValuesFunc: func() ([]interface{}, error) {
// 				panic("mock out the Values method")
// 			},
// 		}
//
// 		// use mockedPGXRows in code that requires pgx.PGXRows
// 		// and then make assertions.
//
// 	}
type PGXRowsMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func()

	// CommandTagFunc mocks the CommandTag method.
	CommandTagFunc func() pgconn.CommandTag

	// ErrFunc mocks the Err method.
	ErrFunc func() error

	// FieldDescriptionsFunc mocks the FieldDescriptions method.
	FieldDescriptionsFunc func() []pgproto3.FieldDescription

	// NextFunc mocks the Next method.
	NextFunc func() bool

	// RawValuesFunc mocks the RawValues method.
	RawValuesFunc func() [][]byte

	// ScanFunc mocks the Scan method.
	ScanFunc func(dest ...interface{}) error

	// ValuesFunc mocks the Values method.
	ValuesFunc func() ([]interface{}, error)

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// CommandTag holds details about calls to the CommandTag method.
		CommandTag []struct {
		}
		// Err holds details about calls to the Err method.
		Err []struct {
		}
		// FieldDescriptions holds details about calls to the FieldDescriptions method.
		FieldDescriptions []struct {
		}
		// Next holds details about calls to the Next method.
		Next []struct {
		}
		// RawValues holds details about calls to the RawValues method.
		RawValues []struct {
		}
		// Scan holds details about calls to the Scan method.
		Scan []struct {
			// Dest is the dest argument value.
			Dest []interface{}
		}
		// Values holds details about calls to the Values method.
		Values []struct {
		}
	}
	lockClose             sync.RWMutex
	lockCommandTag        sync.RWMutex
	lockErr               sync.RWMutex
	lockFieldDescriptions sync.RWMutex
	lockNext              sync.RWMutex
	lockRawValues         sync.RWMutex
	lockScan              sync.RWMutex
	lockValues            sync.RWMutex
}

// Close calls CloseFunc.
func (mock *PGXRowsMock) Close() {
	if mock.CloseFunc == nil {
		panic("PGXRowsMock.CloseFunc: method is nil but PGXRows.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedPGXRows.CloseCalls())
func (mock *PGXRowsMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// CommandTag calls CommandTagFunc.
func (mock *PGXRowsMock) CommandTag() pgconn.CommandTag {
	if mock.CommandTagFunc == nil {
		panic("PGXRowsMock.CommandTagFunc: method is nil but PGXRows.CommandTag was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCommandTag.Lock()
	mock.calls.CommandTag = append(mock.calls.CommandTag, callInfo)
	mock.lockCommandTag.Unlock()
	return mock.CommandTagFunc()
}

// CommandTagCalls gets all the calls that were made to CommandTag.
// Check the length with:
//     len(mockedPGXRows.CommandTagCalls())
func (mock *PGXRowsMock) CommandTagCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCommandTag.RLock()
	calls = mock.calls.CommandTag
	mock.lockCommandTag.RUnlock()
	return calls
}

// Err calls ErrFunc.
func (mock *PGXRowsMock) Err() error {
	if mock.ErrFunc == nil {
		panic("PGXRowsMock.ErrFunc: method is nil but PGXRows.Err was just called")
	}
	callInfo := struct {
	}{}
	mock.lockErr.Lock()
	mock.calls.Err = append(mock.calls.Err, callInfo)
	mock.lockErr.Unlock()
	return mock.ErrFunc()
}

// ErrCalls gets all the calls that were made to Err.
// Check the length with:
//     len(mockedPGXRows.ErrCalls())
func (mock *PGXRowsMock) ErrCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockErr.RLock()
	calls = mock.calls.Err
	mock.lockErr.RUnlock()
	return calls
}

// FieldDescriptions calls FieldDescriptionsFunc.
func (mock *PGXRowsMock) FieldDescriptions() []pgproto3.FieldDescription {
	if mock.FieldDescriptionsFunc == nil {
		panic("PGXRowsMock.FieldDescriptionsFunc: method is nil but PGXRows.FieldDescriptions was just called")
	}
	callInfo := struct {
	}{}
	mock.lockFieldDescriptions.Lock()
	mock.calls.FieldDescriptions = append(mock.calls.FieldDescriptions, callInfo)
	mock.lockFieldDescriptions.Unlock()
	return mock.FieldDescriptionsFunc()
}

// FieldDescriptionsCalls gets all the calls that were made to FieldDescriptions.
// Check the length with:
//     len(mockedPGXRows.FieldDescriptionsCalls())
func (mock *PGXRowsMock) FieldDescriptionsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockFieldDescriptions.RLock()
	calls = mock.calls.FieldDescriptions
	mock.lockFieldDescriptions.RUnlock()
	return calls
}

// Next calls NextFunc.
func (mock *PGXRowsMock) Next() bool {
	if mock.NextFunc == nil {
		panic("PGXRowsMock.NextFunc: method is nil but PGXRows.Next was just called")
	}
	callInfo := struct {
	}{}
	mock.lockNext.Lock()
	mock.calls.Next = append(mock.calls.Next, callInfo)
	mock.lockNext.Unlock()
	return mock.NextFunc()
}

// NextCalls gets all the calls that were made to Next.
// Check the length with:
//     len(mockedPGXRows.NextCalls())
func (mock *PGXRowsMock) NextCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNext.RLock()
	calls = mock.calls.Next
	mock.lockNext.RUnlock()
	return calls
}

// RawValues calls RawValuesFunc.
func (mock *PGXRowsMock) RawValues() [][]byte {
	if mock.RawValuesFunc == nil {
		panic("PGXRowsMock.RawValuesFunc: method is nil but PGXRows.RawValues was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRawValues.Lock()
	mock.calls.RawValues = append(mock.calls.RawValues, callInfo)
	mock.lockRawValues.Unlock()
	return mock.RawValuesFunc()
}

// RawValuesCalls gets all the calls that were made to RawValues.
// Check the length with:
//     len(mockedPGXRows.RawValuesCalls())
func (mock *PGXRowsMock) RawValuesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRawValues.RLock()
	calls = mock.calls.RawValues
	mock.lockRawValues.RUnlock()
	return calls
}

// Scan calls ScanFunc.
func (mock *PGXRowsMock) Scan(dest ...interface{}) error {
	if mock.ScanFunc == nil {
		panic("PGXRowsMock.ScanFunc: method is nil but PGXRows.Scan was just called")
	}
	callInfo := struct {
		Dest []interface{}
	}{
		Dest: dest,
	}
	mock.lockScan.Lock()
	mock.calls.Scan = append(mock.calls.Scan, callInfo)
	mock.lockScan.Unlock()
	return mock.ScanFunc(dest...)
}

// ScanCalls gets all the calls that were made to Scan.
// Check the length with:
//     len(mockedPGXRows.ScanCalls())
func (mock *PGXRowsMock) ScanCalls() []struct {
	Dest []interface{}
} {
	var calls []struct {
		Dest []interface{}
	}
	mock.lockScan.RLock()
	calls = mock.calls.Scan
	mock.lockScan.RUnlock()
	return calls
}

// Values calls ValuesFunc.
func (mock *PGXRowsMock) Values() ([]interface{}, error) {
	if mock.ValuesFunc == nil {
		panic("PGXRowsMock.ValuesFunc: method is nil but PGXRows.Values was just called")
	}
	callInfo := struct {
	}{}
	mock.lockValues.Lock()
	mock.calls.Values = append(mock.calls.Values, callInfo)
	mock.lockValues.Unlock()
	return mock.ValuesFunc()
}

// ValuesCalls gets all the calls that were made to Values.
// Check the length with:
//     len(mockedPGXRows.ValuesCalls())
func (mock *PGXRowsMock) ValuesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockValues.RLock()
	calls = mock.calls.Values
	mock.lockValues.RUnlock()
	return calls
}
